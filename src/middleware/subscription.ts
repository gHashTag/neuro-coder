import { SessionFlavor, Context, InlineKeyboard } from "grammy"
import { createUser, getUid } from "../core/supabase"
import { ChatMembersFlavor } from "@grammyjs/chat-members"
import { MyContext, SessionData } from "../utils/types"

import { ConversationFlavor } from "@grammyjs/conversations"
import { bot } from "../index"

// –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∏–ø –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
export type MyContextChatMembers = Context & SessionFlavor<SessionData> & ConversationFlavor & ChatMembersFlavor

export type MyContextWithSession = MyContext & SessionFlavor<SessionData>
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º chat-members
async function checkSubscription(ctx: MyContextChatMembers): Promise<boolean> {
  try {
    if (!ctx.from?.id) {
      console.error("User ID is undefined")
      throw new Error("User ID is undefined")
    }
    const chatMember = await bot.api.getChatMember("@neuro_blogger_group", ctx.from?.id)
    return ["member", "administrator", "creator"].includes(chatMember.status)
  } catch (error) {
    console.error("Error checking subscription:", error)
    throw error
  }
}

// –û—Å–Ω–æ–≤–Ω–æ–π middleware
export const subscriptionMiddleware = async (ctx: MyContextChatMembers, next: () => Promise<void>) => {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–º–∞–Ω–¥–∞ /start
    if (ctx.message?.text !== "/start") {
      return await next()
    }
    if (!ctx.from) {
      console.error("No user data found in context")
      return await ctx.reply("Error: No user data found")
    }

    // –ü–æ–ª—É—á–∞–µ–º inviter_id –∏–∑ start –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
    const startPayload = (ctx.message?.text || "").split(" ")[1]

    console.log("startPayload", startPayload)
    const inviter = await getUid(startPayload)

    const { username, id: telegram_id, first_name, last_name, is_bot, language_code } = ctx.from

    const finalUsername = username || first_name || telegram_id.toString()
    const photo_url = await getUserPhotoUrl(ctx, telegram_id)

    const isSubscribed = await checkSubscription(ctx)
    if (!isSubscribed) {
      return await ctx.reply(
        language_code === "ru"
          ? "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞. üòä"
          : "Please subscribe to our channel to continue using the bot. üòä",
        {
          reply_markup: new InlineKeyboard().url(language_code === "ru" ? "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è" : "Subscribe", "https://t.me/neuro_blogger_group"),
        },
      )
    }

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å inviter –∏–∑ start –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
    const userData = {
      username: finalUsername,
      telegram_id: telegram_id.toString(),
      first_name: first_name || null,
      last_name: last_name || null,
      is_bot: is_bot || false,
      language_code: language_code || "en",
      photo_url,
      chat_id: ctx.chat?.id || null,
      mode: "clean",
      model: "gpt-4-turbo",
      count: 0,
      limit: 200,
      aspect_ratio: "9:16",
      balance: 100,
      inviter,
    }

    await createUser(userData)

    return await next()
  } catch (error) {
    console.error("Critical error in subscriptionMiddleware:", error)
    const isRu = ctx.from?.language_code === "ru"
    return await ctx.reply(isRu ? "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ." : "A critical error occurred. Please try again later.")
    throw error
  }
}

async function getUserPhotoUrl(ctx: MyContextChatMembers, userId: number): Promise<string | null> {
  try {
    // –ü–æ–ª—É—á–∞–µ–º –º–∞—Å—Å–∏–≤ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –ø—Ä–æ—Ñ–∏–ª—è
    const userPhotos = await ctx.api.getUserProfilePhotos(userId, {
      limit: 1,
      offset: 0,
    })

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
    if (userPhotos.total_count === 0) {
      console.log("No photos found")
      return null
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª —Å–∞–º–æ–≥–æ –±–æ–ª—å—à–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–æ—Ç–æ
    const photoSizes = userPhotos.photos[0]
    const largestPhoto = photoSizes[photoSizes.length - 1]

    console.log("Largest photo:", largestPhoto)

    const file = await ctx.api.getFile(largestPhoto.file_id)
    console.log("File info:", file)

    if (!file.file_path) {
      console.log("No file_path in response")
      return null
    }

    // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
    const photoUrl = `https://api.telegram.org/file/bot${ctx.api.token}/${file.file_path}`
    console.log("Generated photo URL:", photoUrl)

    return photoUrl
  } catch (error) {
    console.error("Error getting user profile photo:", error)
    throw error
  }
}
